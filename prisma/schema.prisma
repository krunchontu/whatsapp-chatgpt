// Prisma Schema for WhatsApp AI Customer Service Bot
// Supports both SQLite (MVP) and PostgreSQL (production scale)

// To switch from SQLite to PostgreSQL:
// 1. Change provider to "postgresql"
// 2. Update DATABASE_URL to postgres connection string
// 3. Run: npx prisma migrate dev
// 4. All migrations will work with both databases

datasource db {
  provider = "sqlite" // Change to "postgresql" when scaling
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  // Optimization: smaller client size
  binaryTargets = ["native"]
}

// ============================================== #
//                User Management                 #
// ============================================== #

// Note: SQLite doesn't support enums, so we use String with app-level validation
// Valid Role values: "OWNER" | "ADMIN" | "OPERATOR" | "USER"
// Role Hierarchy: OWNER (4) > ADMIN (3) > OPERATOR (2) > USER (1)
// - OWNER: Full system access, can manage all roles
// - ADMIN: Team lead, can manage operators and users
// - OPERATOR: Customer service agent, limited access
// - USER: Customer, can chat with bot

model User {
  id            String  @id @default(cuid())
  phoneNumber   String  @unique
  role          String  @default("USER") // "OWNER" | "ADMIN" | "OPERATOR" | "USER"
  isWhitelisted Boolean @default(false)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  conversations Conversation[]
  usageMetrics  UsageMetric[]
  auditLogs     AuditLog[]

  @@index([phoneNumber])
  @@map("users")
}

// ============================================== #
//            Conversation Memory                 #
// ============================================== #

model Conversation {
  id     String @id @default(cuid())
  userId String

  // JSON array of messages: [{role: "user"|"assistant", content: "...", timestamp: "..."}]
  // Stores last 10 messages for context
  messages String // JSON string (SQLite limitation)

  // Metadata
  messageCount Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  expiresAt DateTime // TTL for privacy (7 days default)

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([expiresAt]) // For cleanup job
  @@map("conversations")
}

// ============================================== #
//           Usage Tracking & Costs               #
// ============================================== #

// Note: SQLite doesn't support enums, so we use String with app-level validation
// Valid OperationType values: "CHAT" | "TRANSCRIPTION" | "VISION"
// - CHAT: GPT chat completion
// - TRANSCRIPTION: Whisper voice transcription
// - VISION: GPT vision (image analysis)

model UsageMetric {
  id     String @id @default(cuid())
  userId String

  // Token counts
  promptTokens     Int
  completionTokens Int
  totalTokens      Int

  // Cost in USD (stored as integer, divide by 1,000,000 for actual cost)
  // Example: 5250 = $0.005250
  // SQLite doesn't have Decimal type, so we store as Int
  costMicros Int // Cost in micro-dollars (1/1,000,000 of a dollar)

  // Model and operation
  model     String // e.g., "gpt-4o", "whisper-1"
  operation String // "CHAT" | "TRANSCRIPTION" | "VISION"

  // Timestamps
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([createdAt]) // For daily aggregation
  @@map("usage_metrics")
}

// ============================================== #
//           System Configuration                 #
// ============================================== #

model SystemConfig {
  key   String @id
  value String // JSON string

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("system_config")
}

// ============================================== #
//              Audit Logging                     #
// ============================================== #

// Note: SQLite doesn't support enums, so we use String with app-level validation
// Valid AuditCategory values: "AUTH" | "CONFIG" | "ADMIN" | "SECURITY"
// - AUTH: Authentication and authorization events (role changes, permission denials)
// - CONFIG: Configuration changes (bot settings, system config)
// - ADMIN: Administrative actions (usage queries, audit log views)
// - SECURITY: Security events (rate limits, moderation flags, circuit breaker)

model AuditLog {
  id String @id @default(cuid())

  // Who performed the action (nullable for system-generated events)
  userId      String?
  phoneNumber String // Always track phone number
  userRole    String // Role at time of action

  // What happened
  action      String // e.g., "ROLE_CHANGE", "CONFIG_UPDATE", "PERMISSION_DENIED"
  category    String // "AUTH" | "CONFIG" | "ADMIN" | "SECURITY"
  description String // Human-readable description

  // Context (JSON string with additional metadata)
  // Examples:
  // - Role change: {"oldRole": "USER", "newRole": "OPERATOR", "targetUserId": "xyz"}
  // - Config update: {"setting": "gpt.model", "oldValue": "gpt-3.5", "newValue": "gpt-4o"}
  // - Permission denied: {"action": "VIEW_AUDIT_LOGS", "requiredRole": "ADMIN"}
  metadata String // JSON string (SQLite limitation)

  // When
  createdAt DateTime @default(now())

  // Relations (nullable because system events may not have a user)
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  // Indexes for common queries
  @@index([userId, createdAt])
  @@index([category, createdAt])
  @@index([action, createdAt])
  @@index([phoneNumber, createdAt])
  @@index([createdAt]) // For retention policy cleanup
  @@map("audit_logs")
}

// ============================================== #
//              Migration Notes                   #
// ============================================== #

// SQLite Limitations:
// 1. No native Decimal type → use Int (micro-dollars)
// 2. No native JSON type → use String with JSON.parse/stringify
// 3. No native Enum type → use String with app-level validation
// 4. Limited concurrent writes (~10/sec) → sufficient for MVP

// PostgreSQL Migration (when needed):
// 1. Change provider to "postgresql"
// 2. Change costMicros to: cost Decimal @db.Decimal(10, 6)
// 3. Change messages to: messages Json
// 4. Add back enums: enum Role { ADMIN, USER }
// 5. Change role/operation String to enum types
// 6. Run: npx prisma migrate dev
// 7. Data migration: export from SQLite, import to Postgres
